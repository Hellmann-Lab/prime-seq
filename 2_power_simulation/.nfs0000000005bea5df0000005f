---
title: "prime-seq UHRR Comparison"
author: "Aleks Janjic"
date: "06/08/2020"
output:
  pdf_document: default
  html_document: default
Script: Bulk_DGE_script
---
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
```
##Purpose: 
Quality check of Foxp2 Atlas libraries from all samples

##Protocol: 

###1. Load the following packages:

```{r packages}
library(plyr)
library(dplyr)
library(tidyr)
library(ggplot2)
library(cowplot)
library(RUVSeq)
library(DESeq2)
library(vsn)
library(ggrepel)
library(edgeR)
library(genefilter)
library(grid)
library(gridExtra)
library(HTSFilter)
library(ggsci)
library(fastqcr)
```

###2. Load following functions:


```{r functions}
#Function for selecting genes expressed in at least x% of samples
whichgenes_reproducible <- function(exprtable,exprcutoff,reproducecutoff){
  expressedgenes <- row.names(exprtable[which(rowSums(exprtable)>=exprcutoff),])
  tmp <- exprtable[expressedgenes,]
  ndetections <- rowSums(exprtable[expressedgenes,]>=1)
  outgenes <- names(ndetections[which(ndetections/ncol(exprtable)>=reproducecutoff)])
  return(outgenes)
}

#load generate stats function
generate_stats <- function(exprdf,conds){
  require(matrixStats)
  if(length(conds)!=ncol(exprdf)){
    print("Erorr in Conditions given")
    stop()
  }
  conds_vec <- unique(conds)
  cvfrommatrix <- function(exprmatrix){
    exprtmp <- as.matrix(exprmatrix)
    cv <- (matrixStats::rowSds(exprtmp)/rowMeans(exprtmp))
    return(cv)
  }
  calcp0 <- function(exprtable){
    nsamples = dim(exprtable)[2]
    nn0 = rowSums(!exprtable)
    p0 = 1 - ((nsamples - nn0)/nsamples)
    return(p0)
  }
  output_df_collect <- data.frame(GeneID=NA,mu=NA,cv=NA,p0=NA,cond=NA,stringsAsFactors = F)
  for(i in conds_vec){
    tmp_expr <- exprdf[,grep(i,conds)]
    tmp_expr <- tmp_expr[which(rowSums(tmp_expr)>0),]
    output_df_tmp <- data.frame(GeneID=row.names(tmp_expr),
                                mu=rowMeans(tmp_expr),
                                cv=cvfrommatrix(tmp_expr),
                                p0=calcp0(tmp_expr),
                                cond=rep(i,nrow(tmp_expr)),
                                stringsAsFactors = F)
    output_df_collect <- rbind.data.frame(output_df_collect,output_df_tmp) 
  }
  output_df_collect <- output_df_collect[-1,]
  output_df_collect$EPV <- output_df_collect$cv - (sqrt(output_df_collect$mu)/output_df_collect$mu)
  output_df_collect$poisson_cv <- (sqrt(output_df_collect$mu)/output_df_collect$mu)
  return(output_df_collect)
}

theme_pub <- theme_bw() + theme(axis.text = element_text(colour="black", size=14), 
                                axis.title = element_text(colour="black", size=16, face="bold"), 
                                legend.text=element_text(colour="black", size=14),
                                legend.position="right", 
                                axis.line.x = element_line(colour = "black"),
                                axis.line.y = element_line(colour = "black"),
                                axis.ticks.x = element_blank(),
                                strip.background=element_blank(), 
                                strip.text=element_text(size=16))  

#use Lucas Schmitt's PCA Function
source("/data/home/janjic/R_scripts/Klaus_pcafunction.R")

#Normalization Boxplot
source("/data/share/common/scripts/pcafunction.R")
```


###3. Add the data set

Read the RDS file into R, which is the end product of the zUMIs pipeline.

```{r RDS}

counts_prime <- readRDS("/data/share/htp/Bulk_seq_opt/UHRR_IPSC/UHRR/UHRR_HiSeq/zUMIs/zUMIs_output/expression/UHRR.dgecounts.rds")

counts_tru <- readRDS("/data/share/htp/Bulk_seq_opt/Paper/Fig_4_Comparison/Comparison/zUMIs_SE/zUMIs_output/expression/SEQC_SE.dgecounts.rds")

inf_prime <- read.csv("/data/share/htp/Bulk_seq_opt/UHRR_IPSC/UHRR/UHRR_HiSeq/UHRR_info.csv", sep = ",", head = T, stringsAsFactors = F)

inf_tru <- read.csv("/data/share/htp/Bulk_seq_opt/Paper/Fig_4_Comparison/Comparison/sample_info.csv", sep = ",", head = T, stringsAsFactors = F) 
#select only 1 lane from one flow cell
inf_tru <- inf_tru[inf_tru$flowcell == "AC0AYTACXX",]
inf_tru <- inf_tru[inf_tru$Lane == "L01",]

```

###4. Select the exonic UMIs from the RDS

The RDS file is a list which contains multiple data sets.

All will be used as all samples were within the downsampling threshold. 

```{r counts}
### primeseq umis
umi_prime <- as.matrix(counts_prime$umicount$exon$all)
#5,000,000
umi_prime5000 <- as.matrix(counts_prime$umicount$exon$downsampling$downsampled_5000000)
#1,000,000
umi_prime1000 <- as.matrix(counts_prime$umicount$exon$downsampling$downsampled_1000000)
#500,000
umi_prime500 <- as.matrix(counts_prime$umicount$exon$downsampling$downsampled_500000)
#250,000
umi_prime250 <- as.matrix(counts_prime$umicount$exon$downsampling$downsampled_250000)
#50,000
umi_prime50 <- as.matrix(counts_prime$umicount$exon$downsampling$downsampled_50000)
#10,000
umi_prime10 <- as.matrix(counts_prime$umicount$exon$downsampling$downsampled_10000)

### prime-seq reads
reads_prime <- as.matrix(counts_prime$readcount$inex$all)
#5,000,000
reads_prime5000 <- as.matrix(counts_prime$readcount$inex$downsampling$downsampled_5000000)
#1,000,000
reads_prime1000 <- as.matrix(counts_prime$readcount$inex$downsampling$downsampled_1000000)
#500,000
reads_prime500 <- as.matrix(counts_prime$readcount$inex$downsampling$downsampled_500000)
#250,000
reads_prime250 <- as.matrix(counts_prime$readcount$inex$downsampling$downsampled_250000)
#50,000
reads_prime50 <- as.matrix(counts_prime$readcount$inex$downsampling$downsampled_50000)
#10,000
reads_prime10 <- as.matrix(counts_prime$readcount$inex$downsampling$downsampled_10000)

### truseq reads
reads_tru <- as.matrix(counts_tru$readcount$inex$all)
reads_tru <- reads_tru[,colnames(reads_tru) %in% inf_tru$zUMIs_Bcs]
#5,000,000
reads_tru5000 <- as.matrix(counts_tru$readcount$inex$downsampling$downsampled_5000000)
reads_tru5000 <- reads_tru5000[,colnames(reads_tru5000) %in% inf_tru$zUMIs_Bcs]
#1,000,000
reads_tru1000 <- as.matrix(counts_tru$readcount$inex$downsampling$downsampled_1000000)
reads_tru1000 <- reads_tru1000[,colnames(reads_tru1000) %in% inf_tru$zUMIs_Bcs]
#500,000
reads_tru500 <- as.matrix(counts_tru$readcount$inex$downsampling$downsampled_500000)
reads_tru500 <- reads_tru500[,colnames(reads_tru500) %in% inf_tru$zUMIs_Bcs]
#250,000
reads_tru250 <- as.matrix(counts_tru$readcount$inex$downsampling$downsampled_250000)
reads_tru250 <- reads_tru250[,colnames(reads_tru250) %in% inf_tru$zUMIs_Bcs]
#100,000
reads_tru100 <- as.matrix(counts_tru$readcount$inex$downsampling$downsampled_100000)
reads_tru100 <- reads_tru100[,colnames(reads_tru100) %in% inf_tru$zUMIs_Bcs]
#50,000
reads_tru50 <- as.matrix(counts_tru$readcount$inex$downsampling$downsampled_50000)
reads_tru50 <- reads_tru50[,colnames(reads_tru50) %in% inf_tru$zUMIs_Bcs]
#10,000
reads_tru10 <- as.matrix(counts_tru$readcount$inex$downsampling$downsampled_10000)
reads_tru10 <- reads_tru10[,colnames(reads_tru10) %in% inf_tru$zUMIs_Bcs]

```


###8. Filter the genes in the count matrix

Remove genes with zero or low counts using HTS Filter.  

```{r filtering}

###Filtering by % of expression
#create a list of the genes which should be kept (10% and 25%)

reads_prime_filt20_list <- whichgenes_reproducible(reads_prime,1,0.20)
reads_prime_filt40_list <- whichgenes_reproducible(reads_prime,1,0.40)

reads_tru_filt20_list <- whichgenes_reproducible(reads_tru,1,0.20)
reads_tru_filt40_list <- whichgenes_reproducible(reads_tru,1,0.40)


#subset the df with the genes
reads_prime_filt20 <- reads_prime[row.names(reads_prime) %in% reads_prime_filt20_list, ]
reads_prime_filt40 <- reads_prime[row.names(reads_prime) %in% reads_prime_filt40_list, ]

reads_tru_filt20 <- reads_tru[row.names(reads_tru) %in% reads_tru_filt20_list, ]
reads_tru_filt40 <- reads_tru[row.names(reads_tru) %in% reads_tru_filt40_list, ]

#mean gene expression
plot_mean_prime <- ggplot()+
  geom_density(aes(x= rowMeans(reads_prime), fill="Unfiltered"), alpha=0.7)+
  geom_density(aes(x= rowMeans(reads_prime_filt20), fill="20% Filtered"), alpha=0.7)+
  geom_density(aes(x= rowMeans(reads_prime_filt40), fill="40% Filtered"), alpha=0.7)+
  scale_fill_manual(values = c("#003F5A","#DE6600", "#696464"))+
  scale_x_log10()+
  xlab("Mean Gene Expression (log10)")+
  ggtitle("prime-seq")+
  theme_pub+
  theme(legend.title = element_blank())
plot_mean_prime

plot_mean_tru <- ggplot()+
  geom_density(aes(x= rowMeans(reads_tru), fill="Unfiltered"), alpha=0.7)+
  geom_density(aes(x= rowMeans(reads_tru_filt20), fill="20% Filtered"), alpha=0.7)+
  geom_density(aes(x= rowMeans(reads_tru_filt40), fill="40% Filtered"), alpha=0.7)+
  scale_fill_manual(values = c("#003F5A","#DE6600", "#696464"))+
  scale_x_log10()+
  xlab("Mean Gene Expression (log10)")+
  ggtitle("Tru-seq")+
  theme_pub+
  theme(legend.title = element_blank())
plot_mean_tru
```


###9. Gene and UMI Table

```{r genes and umi}

### Genes
df_genes_prime <- data.frame(BC=colnames(reads_prime),
                      DS_1000000 = colSums(reads_prime1000 >0),
                      DS_500000 = colSums(reads_prime500 >0),
                      DS_250000 = colSums(reads_prime250 >0),
                      DS_50000 = colSums(reads_prime50 >0),
                      DS_10000 = colSums(reads_prime10 >0))
df_genes_prime$Method <- "prime-seq" 
df_genes_prime_long <- pivot_longer(df_genes_prime, cols = 2:6, names_to = "Downsampling", values_to = "Genes")

df_genes_tru <- data.frame(BC=colnames(reads_tru),
                      DS_1000000 = colSums(reads_tru1000 >0),
                      DS_500000 = colSums(reads_tru500 >0),
                      DS_250000 = colSums(reads_tru250 >0),
                      DS_50000 = colSums(reads_tru50 >0),
                      DS_10000 = colSums(reads_tru10 >0))
df_genes_tru$Method <- "tru-seq" 
df_genes_tru_long <- pivot_longer(df_genes_tru, cols = 2:6, names_to = "Downsampling", values_to = "Genes")

df_genes_long <- rbind(df_genes_prime_long, df_genes_tru_long)


### Reads
df_reads_prime <- data.frame(BC=colnames(reads_prime),
                      DS_1000000 = colSums(reads_prime1000 ),
                      DS_500000 = colSums(reads_prime500 ),
                      DS_250000 = colSums(reads_prime250 ),
                      DS_50000 = colSums(reads_prime50 ),
                      DS_10000 = colSums(reads_prime10 ))
df_reads_prime$Method <- "prime-seq" 
df_reads_prime_long <- pivot_longer(df_reads_prime, cols = 2:6, names_to = "Downsampling", values_to = "Reads")

df_reads_tru <- data.frame(BC=colnames(reads_tru),
                      DS_1000000 = colSums(reads_tru1000 ),
                      DS_500000 = colSums(reads_tru500 ),
                      DS_250000 = colSums(reads_tru250 ),
                      DS_50000 = colSums(reads_tru50 ),
                      DS_10000 = colSums(reads_tru10 ))
df_reads_tru$Method <- "tru-seq" 
df_reads_tru_long <- pivot_longer(df_reads_tru, cols = 2:6, names_to = "Downsampling", values_to = "Reads")


df_reads_long <- rbind(df_reads_prime_long, df_reads_tru_long)


#prevent scientific notation
options(scipen=999)


```


###10. Plot Number of Genes, UMIs, and Reads by Filtering
 
```{r gene umi read plots}
#reorder downsampling
df_genes_long$Downsampling <- factor(df_genes_long$Downsampling, levels=c("DS_10000", 
                                                                          "DS_50000", 
                                                                          "DS_250000",
                                                                          "DS_500000",
                                                                          "DS_1000000"))
df_reads_long$Downsampling <- factor(df_reads_long$Downsampling, levels=c("DS_10000", 
                                                                          "DS_50000", 
                                                                          "DS_250000",
                                                                          "DS_500000",
                                                                          "DS_1000000"))

#rename downsampling
scale_x_discrete(labels=c("0.5" = "Dose 0.5", "1" = "Dose 1",
                              "2" = "Dose 2"))


plot_genes <-ggplot(data=df_genes_long, aes(x=Downsampling, y=Genes))+
  geom_boxplot(aes(fill=Method), alpha=0.8, position=position_dodge(0.5))+
  geom_point(aes(color=Method),position=position_dodge(0.5))+
  ylab("Number of Genes")+
  scale_color_manual(values = c("dodgerblue4","orangered"))+
  scale_fill_manual(values = c("dodgerblue4","orangered"))+
  theme_pub + 
  theme(legend.position = "bottom")+
  scale_x_discrete(labels= c("DS_10000" = "10,000", "DS_50000" = "50,000", "DS_250000" = "250,000","DS_500000"="500,000","DS_1000000"="1,000,000"))

plot_reads <-ggplot(data=df_reads_long, aes(x=Downsampling, y=Reads))+
  geom_boxplot(aes(fill=Method), alpha=0.8, position=position_dodge(0.5))+
  geom_point(aes(color=Method),position=position_dodge(0.5))+
  ylab("Number of Reads")+
  scale_color_manual(values = c("dodgerblue4","orangered"))+
  scale_fill_manual(values = c("dodgerblue4","orangered"))+
  theme_pub + 
  theme(legend.position = "none")+
  scale_x_discrete(labels= c("DS_10000" = "10,000", "DS_50000" = "50,000", "DS_250000" = "250,000","DS_500000"="500,000","DS_1000000"="1,000,000"))



supp_fig_gene_umi_counts <- cowplot::plot_grid(plot_genes, plot_reads,
  ncol = 1,
  nrow = 2,
  labels = "auto", 
  rel_heights = c(1,0.87)
)


```

###11. Feature Tables

Load readspercell files from zUMIs, which show all features for every i7

```{r feats}
#read files
readspercell <- read.table("/data/share/htp/Foxp2/FoxP2_Atlas/Spike-In2/zUMIs/zUMIs_output/stats/Foxp2Atlas_SpikeIn_2.readspercell.txt", header = T)

colnames(readspercell)[1] <- "XC" 

#add info
readspercell <- inner_join(readspercell, inf, by = "XC")

#calculate number of assigned reads
Assigned <- readspercell %>% group_by(Tissue) %>% summarize(Total=sum(N)) %>% as.data.frame()
colnames(Assigned)[2] <- "Assigned"

#calculate unmapped reads that passed QC
Unmapped <- readspercell %>% group_by(Tissue) %>% filter(type == "Unmapped") %>% summarize(Total=sum(N)) %>% as.data.frame()
colnames(Unmapped)[2] <- "Unmapped"

#calculate ambiguity reads that passed QC
Ambiguous <- readspercell %>% group_by(Tissue) %>% filter(type == "Ambiguity") %>% summarize(Total=sum(N)) %>% as.data.frame()
colnames(Ambiguous)[2] <- "Ambiguous"

#calculate intergenic reads that passed QC
Intergenic <- readspercell %>% group_by(Tissue) %>% filter(type == "Intergenic") %>% summarize(Total=sum(N)) %>% as.data.frame()
colnames(Intergenic)[2] <- "Intergenic"

#calculate intronic reads that passed QC
Intronic <- readspercell %>% group_by(Tissue) %>% filter(type == "Intron") %>% summarize(Total=sum(N)) %>% as.data.frame()
colnames(Intronic)[2] <- "Intronic"

#calculate exonic reads that passed QC
Exonic <- readspercell %>% group_by(Tissue) %>% filter(type == "Exon") %>% summarize(Total=sum(N)) %>% as.data.frame()
colnames(Exonic)[2] <- "Exonic"

#join data frames
dfs <- list(Assigned, Unmapped, Ambiguous, Intergenic, Intronic, Exonic)

readspertissue <- join_all(dfs, by = "Tissue")


#make long
readspertissue_long <- pivot_longer(readspertissue, cols = 3:7)

#change factor levels
readspertissue_long$name<-factor(readspertissue_long$name, levels= rev(c("Exonic","Intronic", "Intergenic", "Ambiguous","Unmapped")))
readspercell <- readspercell[readspercell$type != "User",]
readspercell$type<-factor(readspercell$type, levels= c("Exon", "Intron", "Intergenic", "Ambiguity", "Unmapped"))

#feature bar plot
plot_feat_bar <- ggplot(readspertissue_long, aes(x=Tissue, y=value, fill=name))+
    geom_bar(stat="identity", position = "fill")+
    facet_grid(Tissue~., scales="free") +
    ylab("Fraction of Assigned Reads") +
    scale_y_continuous(breaks=seq(0,1,0.1)) +
    coord_flip() +
    scale_fill_manual(values = c("#545454", "#ffa54f", "#ffd700", "#118730", "#1a5084"))+
    guides(fill = guide_legend(reverse=T))+
    theme_pub+
    theme(legend.title = element_blank(), 
          legend.position="bottom", 
          axis.title.y = element_blank(), 
          #axis.text.y = element_blank(),
          strip.text.y = element_text(angle = 360),
          panel.grid.major = element_blank(), 
          panel.grid.minor = element_blank(),
          axis.ticks.y = element_blank()) 
plot_feat_bar

#feature box plot
plot_feat_box <- ggplot(readspercell, aes(x=Tissue, y=N, fill=Tissue))+
    geom_boxplot()+
    facet_grid(~ type) +
    ylab("Reads") +
    ylim(0,850000) +
    scale_fill_manual(values = rev(c("#E97C61","#E76F51","#EE8959","#F1965D","#F4A261","#EFB366","#ECBC68","#E9C46A","#8AB17D","#5AA786","#2A9D8F","#287271","#275C62","#264653","#3E4158","#4A3F5A","#563C5C","#4E3754"))) +
    theme_pub +
    theme(legend.title = element_blank(), 
          axis.title.y = element_blank(), 
          axis.text.x = element_blank(),
          strip.text.y = element_text(angle = 360),
          axis.ticks.x = element_blank(),
          legend.position = "bottom")+
          guides(fill=guide_legend(nrow=1,byrow=TRUE)) 


plot_feat_box_Lib_Input <- ggplot(readspercell, aes(x=Tissue, y=N, fill=Lib_Input, color=Lib_Input))+
    geom_boxplot()+
    facet_grid(~ type) +
    ylab("Reads") +
    ylim(0,850000) +
    theme_pub +
    theme(axis.title.y = element_blank(), 
          axis.text.x = element_blank(),
          strip.text.y = element_text(angle = 360),
          axis.ticks.x = element_blank(),
          legend.position = "bottom")+
          guides(fill=guide_legend(nrow=1,byrow=TRUE)) 


supp_fig_feat_box <- cowplot::plot_grid(plot_feat_box, plot_feat_box_Lib_Input,
  ncol = 1,
  nrow = 2,
  labels = "auto"
)
supp_fig_feat_box

#intragenic vs intergenic
Intragenic <- left_join(Exonic, Intronic, by = "Tissue")
Intragenic <- Intragenic %>% group_by(Tissue) %>% summarize(Total = sum(Exonic,Intronic))
colnames(Intragenic) <- c("Tissue", "Intragenic")
Intra_Inter <- left_join(Intragenic, Intergenic, by = "Tissue")
Intra_Inter_long <- pivot_longer(Intra_Inter, cols = 2:3)

Intra_Inter_plot <- ggplot(Intra_Inter_long, aes(x=Tissue, y=value, fill=name))+
    geom_bar(stat="identity", position = "fill")+
    ylab("Fraction of Assigned Reads") +
    scale_fill_manual(values = c("#ffd700", "#1a5084"))+
    theme_pub+
    theme(legend.title = element_blank(), 
          legend.position="bottom")
Intra_Inter_plot

#Exonic vs Intronic
Exonic_Intronic <- left_join(Exonic, Intronic, by = "Tissue")
Exonic_Intronic_long <- pivot_longer(Exonic_Intronic, cols = 2:3)
Exonic_Intronic_long$name <- factor(Exonic_Intronic_long$name, levels = c("Intronic", "Exonic"))

Exonic_Intronic_plot <- ggplot(Exonic_Intronic_long, aes(x=Tissue, y=value, fill=name))+
    geom_bar(stat="identity", position = "fill")+
    ylab("Fraction of Assigned Reads") +
    scale_fill_manual(values = c("#118730", "#1a5084"))+
    theme_pub+
    theme(legend.title = element_blank(), 
          legend.position="bottom")
Exonic_Intronic_plot



```


###12. FastQC Plots

```{r}
#load fastqc data
fastqc_dir_1 <- "/data/share/htp/Foxp2/FoxP2_Atlas/Spike-In/fastqc"
fastqc_dir_2 <- "/data/share/htp/Foxp2/FoxP2_Atlas/Spike-In2/fastqc"

files_all_1 <- list.files(fastqc_dir_1, pattern="*lane8_R3_fastqc.zip", full.names = T)
files_all_2 <- list.files(fastqc_dir_2, pattern="*cat_r2_fastqc.zip", full.names = T)
files_all_1b <- list.files(fastqc_dir_1, pattern="*lane8_R1_fastqc.zip", full.names = T)
files_all_2b <- list.files(fastqc_dir_2, pattern="*cat_r1_fastqc.zip", full.names = T)

qc_1 <- qc_read_collection(files_all_1, sample_names = "Spike-In 1")
qc_2 <- qc_read_collection(files_all_2, sample_names = "Spike-In 2")
qc_1b <- qc_read_collection(files_all_1b, sample_names = "Spike-In 1")
qc_2b <- qc_read_collection(files_all_2b, sample_names = "Spike-In 2")

qc_quality_1 <- qc_plot_collection(qc_1, modules = "Per base Sequence Quality") + theme_pub
qc_content_1 <- qc_plot_collection(qc_1, modules = "Per base Sequence Content") + theme_pub 
qc_quality_2 <- qc_plot_collection(qc_2, modules = "Per base Sequence Quality") + theme_pub
qc_content_2 <- qc_plot_collection(qc_2, modules = "Per base Sequence Content") + theme_pub 

qc_quality_1b <- qc_plot_collection(qc_1b, modules = "Per base Sequence Quality") + theme_pub
qc_content_1b <- qc_plot_collection(qc_1b, modules = "Per base Sequence Content") + theme_pub 
qc_quality_2b <- qc_plot_collection(qc_2b, modules = "Per base Sequence Quality") + theme_pub
qc_content_2b <- qc_plot_collection(qc_2b, modules = "Per base Sequence Content") + theme_pub 

fastqc_content_plots_1 <- plot_grid(qc_quality_1, 
                                  qc_content_1,
          rel_widths = c(1,1),
          cols = 2)
fastqc_content_plots_2 <- plot_grid(qc_quality_2, 
                                  qc_content_2,
          rel_widths = c(1,1),
          cols = 2)
fastqc_content_plots <- plot_grid(fastqc_content_plots_1, fastqc_content_plots_2, 
                                  cols = 1)

fastqc_content_plots_1b <- plot_grid(qc_quality_1b, 
                                  qc_content_1b,
          rel_widths = c(1,1),
          cols = 2)
fastqc_content_plots_2b <- plot_grid(qc_quality_2b, 
                                  qc_content_2b,
          rel_widths = c(1,1),
          cols = 2)
fastqc_content_plotsb <- plot_grid(fastqc_content_plots_1b, fastqc_content_plots_2b, 
                                  cols = 1)

```



###9. Create a DESeq object

The data is first aligned properly, making sure the barcodes in the information table are in the same order as those in the count table.  

```{r dds}

#change row names to barcodes
rownames(inf) <- inf$XC

#make sure bc are in same order as count table
inf <-inf[colnames(umi),]

#create DESeq object
dds <- DESeqDataSetFromMatrix(countData = umi,
                                   colData = inf,
                                   design = ~ Foxp2 + Tissue + Foxp2:Tissue)


```

###10. Estimate size factors

Correction for library size

```{r size factors}
dds<- estimateSizeFactors(dds)

sizeFactors(dds)

#Check histogram of size factors
hist(sizeFactors(dds))
```

###11. Estimate dispersion factors

Dispersion parameter links the variance and mean of the count for the negative binomial distribution

```{r dispersion factors}
#estimate dispersion factors
dds<- estimateDispersions(dds)

```


###13. Look at the dispersion estimates

```{r disp plots}
plotDispEsts(dds)

```

###14. Variance Stabilization 

Either rlog or vsd can be used with DESeq2. The rlog transformation is preferable to the
vsd transformation if the size factors vary widely (>5 fold)

```{r rlog transform}
rlogdds <- varianceStabilizingTransformation(dds)

#extract the matrix of normalized counts
rlogMatdds <- assay(rlogdds)

```

###15. Visualize the stabilization 

Generate a mean SD plot and a normalized box plot

```{r norm vis}
#SD plot
meanSdPlot(rlogMatdds)


#Normalization Boxplot
normBox <-normBoxplot(rlogMatdds)

plot_grid(normBox)

```

###16. Generate PCA for visualizing variance


```{r PCA}
# to label the points: ggrepel::geom_text_repel(aes(label=inf_jmjd$BC), color="black")

#PCA:
#Tissue
PCA12_tissue<- pcaFunction12(mat=rlogMatdds, inf=inf,col="Tissue", ngenes = 500, alpha = 0.9) + 
  scale_color_manual(values = rev(c("#E97C61","#E76F51","#EE8959","#F1965D","#F4A261","#EFB366","#ECBC68","#E9C46A","#8AB17D","#5AA786","#2A9D8F","#287271","#275C62","#264653","#3E4158","#4A3F5A","#563C5C","#4E3754"))) +
  theme_pub + 
  ggtitle("Tissue")+
  theme(legend.position = "none", legend.title = element_blank())
PCA23_tissue<- pcaFunction23(mat=rlogMatdds, inf=inf,col="Tissue", ngenes = 500, alpha = 0.9) + 
  scale_color_manual(values = rev(c("#E97C61","#E76F51","#EE8959","#F1965D","#F4A261","#EFB366","#ECBC68","#E9C46A","#8AB17D","#5AA786","#2A9D8F","#287271","#275C62","#264653","#3E4158","#4A3F5A","#563C5C","#4E3754"))) +
  theme_pub +   
  ggtitle("Tissue")+
  theme(legend.position = "right", legend.title = element_blank())

#Genotype
PCA12_foxp2<- pcaFunction12(mat=rlogMatdds, inf=inf,col="Foxp2", ngenes = 500, alpha = 0.9) + 
  scale_color_npg()+ 
  theme_pub +   
  ggtitle("Genotype")+
  theme(legend.position = "none", legend.title = element_blank())
PCA23_foxp2<- pcaFunction23(mat=rlogMatdds, inf=inf,col="Foxp2", ngenes = 500, alpha = 0.9) + 
  scale_color_npg()+ 
  theme_pub +   
  ggtitle("Genotype")+
  theme(legend.position = "right", legend.title = element_blank())

#UMIs
df_combo_num_umi <- df_combo[,1:7]
rownames(df_combo_num_umi) <- df_combo_num_umi$XC
PCA12_UMIs<- pcaFunction12(mat=rlogMatdds, inf=df_combo_num_umi, col="NUM_UMI", ngenes = 500, alpha = 0.9) + 
  theme_pub +   
  ggtitle("UMIs")+
  theme(legend.position = "right", legend.title = element_blank())
PCA23_UMIs<- pcaFunction23(mat=rlogMatdds, inf=df_combo_num_umi, col="NUM_UMI", ngenes = 500, alpha = 0.9) + 
  theme_pub +   
  ggtitle("UMIs")+
  theme(legend.position = "right", legend.title = element_blank())

#Genes
PCA12_Genes<- pcaFunction12(mat=rlogMatdds, inf=df_combo_num_umi, col="NUM_GENES", ngenes = 500, alpha = 0.9) + 
  theme_pub +   
  ggtitle("Genes")+
  theme(legend.position = "right", legend.title = element_blank())
PCA23_Genes<- pcaFunction23(mat=rlogMatdds, inf=df_combo_num_umi, col="NUM_GENES", ngenes = 500, alpha = 0.9) + 
  theme_pub +   
  ggtitle("Genes")+
  theme(legend.position = "right", legend.title = element_blank())

#Library Input
PCA12_libinput<- pcaFunction12(mat=rlogMatdds, inf=inf, col="Lib_Input", ngenes = 500, alpha = 0.9) + 
  theme_pub +  
  ggtitle("Library Input")+
  theme(legend.position = "right", legend.title = element_blank())
PCA12_libinput<- pcaFunction12(mat=rlogMatdds, inf=inf, col="Lib_Input", ngenes = 500, alpha = 0.9) + 
  theme_pub +  
  ggtitle("Library Input")+
  theme(legend.position = "right", legend.title = element_blank())

#Sex
PCA12_sex<- pcaFunction12(mat=rlogMatdds, inf=inf, col="Sex", ngenes = 500, alpha = 0.9) + 
  scale_color_npg()+ 
  theme_pub +  
  ggtitle("Sex")+
  theme(legend.position = "right", legend.title = element_blank())
PCA23_sex<- pcaFunction23(mat=rlogMatdds, inf=inf, col="Sex", ngenes = 500, alpha = 0.9) + 
  scale_color_npg()+ 
  theme_pub +  
  ggtitle("Sex")+
  theme(legend.position = "right", legend.title = element_blank())

#Batch Number
inf$Batch <- as.character(inf$Batch)
PCA12_batch<- pcaFunction12(mat=rlogMatdds, inf=inf, col="Batch", ngenes = 500, alpha = 0.9) + 
  scale_color_npg()+ 
  theme_pub + 
  ggtitle("Batch Number")+
  theme(legend.position = "right", legend.title = element_blank())
PCA23_batch<- pcaFunction23(mat=rlogMatdds, inf=inf, col="Batch", ngenes = 500, alpha = 0.9) + 
  scale_color_npg()+ 
  theme_pub + 
  ggtitle("Batch Number")+
  theme(legend.position = "right", legend.title = element_blank())


PCA_plots <- plot_grid(PCA12_foxp2, PCA23_foxp2,
                       PCA12_tissue, PCA23_tissue,
                       PCA12_sex, PCA12_batch,
                       PCA12_Genes,PCA12_UMIs,
          cols = 2)

```


###17. Check Xist gene 

Precautionary check to verify that sex of animals matches information sheet
  - Xist gene (mouse-ENSMUSG00000086503 and human-ENSG00000229807) was checked in not subsetted umi table. All samples expressed even levels of xist and confirmed with MWL that they were all female. 

```{r xist}
rlogMatsex<- rlogMatdds["ENSMUSG00000086503", ]
library(reshape)
rlogMatsex<- melt(rlogMatsex)
rlogMatsex <- tibble::rownames_to_column(as.data.frame(rlogMatsex))
colnames(rlogMatsex)<- c("XC","Xist")
rlogMatsex<- left_join(rlogMatsex, inf, by="XC")

Xistplot <-ggplot(rlogMatsex, aes(x=Sample, y = Xist, color=Sex)) + 
  geom_bar(stat= "identity") + 
  theme_pub + 
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) + 
  scale_color_npg()
```

###18. Differential Expresion Analysis using DESeq2

### LRT 

Full design: ~ Foxp2 + Tissue + Sex + Batch

```{r LRT}
# ### reduce Sex
# # Likelihood ratio test
# dds_lrt_sex <- DESeq(dds, test="LRT", reduced = ~ Foxp2 + Tissue)
# # Extract results
# res_LRT_sex <- results(dds_lrt_sex, alpha = 0.05)
# # Subset the LRT results to return genes with padj < 0.05
# head(res_LRT_sex)
# plotMA(res_LRT_sex)
# res_LRT_sex <- na.omit(res_LRT_sex)
# summary(res_LRT_sex)
# subset_res_LRT_sex <- as.matrix(subset(res_LRT_sex, res_LRT_sex[ , 6] < 0.05))


# ### reduce Batch
# # Likelihood ratio test
# dds_lrt_batch <- DESeq(dds, test="LRT", reduced = ~ Foxp2 + Tissue + Sex)
# # Extract results
# res_LRT_batch <- results(dds_lrt_batch, alpha = 0.05)
# # Subset the LRT results to return genes with padj < 0.05
# head(res_LRT_batch)
# plotMA(res_LRT_batch)
# res_LRT_batch <- na.omit(res_LRT_batch)
# summary(res_LRT_batch)
# subset_res_LRT_batch <- as.matrix(subset(res_LRT_batch, res_LRT_batch[ , 6] < 0.05))

# ### reduce Foxp2
# # Likelihood ratio test
# dds_lrt_foxp2 <- DESeq(dds, test="LRT", reduced = ~ Tissue + Sex)
# # Extract results
# res_LRT_foxp2 <- results(dds_lrt_foxp2, alpha = 0.05)
# # Subset the LRT results to return genes with padj < 0.05
# head(res_LRT_foxp2)
# plotMA(res_LRT_foxp2)
# res_LRT_foxp2 <- na.omit(res_LRT_foxp2)
# summary(res_LRT_foxp2)
# subset_res_LRT_foxp2 <- as.matrix(subset(res_LRT_foxp2, res_LRT_foxp2[ , 6] < 0.05))
# 
# ### reduce Tissue
# # Likelihood ratio test
# dds_lrt_tissue <- DESeq(dds, test="LRT", reduced = ~ Foxp2 + Sex)
# # Extract results
# res_LRT_tissue <- results(dds_lrt_tissue, alpha = 0.05)
# # Subset the LRT results to return genes with padj < 0.05
# head(res_LRT_tissue)
# plotMA(res_LRT_tissue)
# res_LRT_tissue <- na.omit(res_LRT_tissue)
# summary(res_LRT_tissue)
# subset_res_LRT_tissue <- as.matrix(subset(res_LRT_tissue, res_LRT_tissue[ , 6] < 0.05))

```
Conclusion:

Design: foxp2 + tissue + sex + batch -- seems that batch and sex don't have a strong effect; will go back and remove batch from full design and repeat LRT

Design: foxp2 + tissue + sex -- sex doesnt have a strong impact either

Design: foxp2 + tissue + foxp2:tissue


#### Wald Test

New Design based on LRT:


```{r exon deseq}
#run DESeq
dds_wald <- DESeq(dds, test="Wald")
resultsNames(dds_wald)
summary(dds_wald)

# WT vs KI
KI_vs_WT <- results(dds_wald,
                     contrast= c("Foxp2", "WT", "KI"),
                     independentFiltering = TRUE,
                     alpha = 0.05,
                     pAdjustMethod = "BY")
KI_vs_WT <- na.omit(KI_vs_WT)
summary(KI_vs_WT)

# WT vs KO
KO_vs_WT <- results(dds_wald,
                     contrast= c("Foxp2", "WT", "KO"),
                     independentFiltering = TRUE,
                     alpha = 0.05,
                     pAdjustMethod = "BY")
KO_vs_WT <- na.omit(KO_vs_WT)
summary(KO_vs_WT)

# Pons
KI_vs_WT_PON <- results(dds_wald,
                     name = "Foxp2KI.TissuePON",
                     independentFiltering = TRUE,
                     alpha = 0.05,
                     pAdjustMethod = "BY")
KI_vs_WT_PON <- na.omit(KI_vs_WT_PON)
summary(KI_vs_WT_PON)

# Midbrain
KI_vs_WT_MID <- results(dds_wald,
                     name = "Foxp2KI.TissueMID",
                     independentFiltering = TRUE,
                     alpha = 0.05,
                     pAdjustMethod = "BY")
KI_vs_WT_MID <- na.omit(KI_vs_WT_MID)
summary(KI_vs_WT_MID)

# Thalamus
KI_vs_WT_THA <- results(dds_wald,
                     name = "Foxp2KI.TissueTHA",
                     independentFiltering = TRUE,
                     alpha = 0.05,
                     pAdjustMethod = "BY")
KI_vs_WT_THA <- na.omit(KI_vs_WT_THA)
summary(KI_vs_WT_THA)

# Motor Cortex
KI_vs_WT_MCO <- results(dds_wald,
                     name = "Foxp2KI.TissueMCO",
                     independentFiltering = TRUE,
                     alpha = 0.05,
                     pAdjustMethod = "BY")
KI_vs_WT_MCO <- na.omit(KI_vs_WT_MCO)
summary(KI_vs_WT_MCO)

# Ventral Striatum
KI_vs_WT_VES <- results(dds_wald,
                     name = "Foxp2KI.TissueVES",
                     independentFiltering = TRUE,
                     alpha = 0.05,
                     pAdjustMethod = "BY")
KI_vs_WT_VES <- na.omit(KI_vs_WT_VES)
summary(KI_vs_WT_VES)

# Dorsal Striatum
KI_vs_WT_DOS <- results(dds_wald,
                     name = "Foxp2KI.TissueDOS",
                     independentFiltering = TRUE,
                     alpha = 0.05,
                     pAdjustMethod = "BH")
KI_vs_WT_DOS <- na.omit(KI_vs_WT_DOS)
summary(KI_vs_WT_DOS)

# Amygdala
KI_vs_WT_AMY <- results(dds_wald,
                     name = "Foxp2KI.TissueAMY",
                     independentFiltering = TRUE,
                     alpha = 0.05,
                     pAdjustMethod = "BH")
KI_vs_WT_AMY <- na.omit(KI_vs_WT_AMY)
summary(KI_vs_WT_AMY)

# Medulla




```




#########################################################################################################################

###19. Gene Ontology 
  
  - Want to know if any nodes contain more significant genes than expected
  - Perform TopGo on experiments which had DEGs

```{r topgo packages}
library(topGO)
library(org.Hs.eg.db)
```

#### 

```{r go}
#order the data by padj value and log fold change
subset <- subset(ipsc_v_npc, ipsc_v_npc[ , 6] < 0.05)
fc <- abs(subset$log2FoldChange)
ordered <- subset[order(fc, decreasing=T),]
head(ordered)
summary(ordered)

###topgo testing
padj <- ipsc_v_npc$padj
names(padj) <- rownames(ipsc_v_npc)
up <- padj
down <- padj

#if you want to just test up-regulated genes
up[ipsc_v_npc$log2FoldChange<0]=1
up <- na.omit(up)

down[ipsc_v_npc$log2FoldChange>0]=1
down <- na.omit(down)

topDiffGenes <- function(x){return(x<0.05)}

tg.1 <- new("topGOdata",
            description = "iPSC vs NPC",
            ontology = "BP",
            allGenes = padj,
            geneSel = topDiffGenes,
            annot = annFUN.org,
            nodeSize = 10,
            ID = "ENSEMBL",
            mapping = "org.Hs.eg.db")

numGenes(tg.1)
numSigGenes(tg.1)
fisher.res1<- runTest(tg.1,
                     algorithm = "elim",
                     statistic = "fisher")
fisher.res1
fishtab1 <- GenTable(tg.1, Fisher = fisher.res1 , orderBy="Fisher" )

fishtab1

tg.1.up <- new("topGOdata",
            description = "iPSC vs NPC up",
            ontology = "BP",
            allGenes = up,
            geneSel = topDiffGenes,
            annot = annFUN.org,
            nodeSize = 10,
            ID = "ENSEMBL",
            mapping = "org.Hs.eg.db")

numGenes(tg.1.up)
numSigGenes(tg.1.up)
fisher.res1.up<- runTest(tg.1.up,
                     algorithm = "elim",
                     statistic = "fisher")
fisher.res1.up
fishtab1.up <- GenTable(tg.1.up, Fisher = fisher.res1.up , orderBy="Fisher" )

fishtab1.up

tg.1.down <- new("topGOdata",
            description = "iPSC vs NPC down",
            ontology = "BP",
            allGenes = down,
            geneSel = topDiffGenes,
            annot = annFUN.org,
            nodeSize = 10,
            ID = "ENSEMBL",
            mapping = "org.Hs.eg.db")

numGenes(tg.1.down)
numSigGenes(tg.1.down)
fisher.res1.down<- runTest(tg.1.down,
                     algorithm = "elim",
                     statistic = "fisher")
fisher.res1.down
fishtab1.down <- GenTable(tg.1.down, Fisher = fisher.res1.down , orderBy="Fisher" )

fishtab1.down

```

###19. Heat Maps
  

```{r topgo packages}
library(SingleR)
library(scater)
library(biomaRt)
library(pheatmap)
library(forcats)
```


## Cell Characterization Heat Map
```{r singleR}

#reference dataset
hpca.se <- HumanPrimaryCellAtlasData()
hpca.se

#normalized dataset
npc_cnts <- counts(dds, normalize = T)

#change dataset rownames to symbols
ens <- useMart("ensembl") 
ens <- useDataset("hsapiens_gene_ensembl",ens)
bm <- getBM(attributes = c("ensembl_gene_id","external_gene_name"),
            filters = "ensembl_gene_id",
            values = row.names(npc_cnts),
            mart = ens)

npc_cnts <- npc_cnts[match(bm$ensembl_gene_id,row.names(npc_cnts)),]
row.names(npc_cnts) <- bm$external_gene_name

# test if row names are now symbols
head(row.names(npc_cnts))

#pick common gene names between data set and ref 
common <- intersect(rownames(npc_cnts), rownames(hpca.se))
hpca.se <- hpca.se[common,]
npc_cnts_common <- npc_cnts[common,]

#singeR predictions
pred.npc <- SingleR(test = npc_cnts_common, ref = hpca.se, labels = hpca.se$label.main, method = "single")

#cell classification heatmap
sample.annotation <- inf[,c("Individual","Celltype"),drop=F]
ann_colors = list(
    Celltype = c(iPSC = "#E8B4B0", NPC = "#245D82"),
    Individual = c(Human1 = "#303030", Human2 = "#545454",Human3 = "#7C7C7C", Human4 = "#A6A6A6", Human5 = "#D1D1D1")
)

singleR_heat <- plotScoreHeatmap(pred.npc, 
                                 max.labels = 5, 
                                 annotation_col = sample.annotation,
                                 cluster_rows = F,
                                 treeheight_col = 25, 
                                 cutree_cols = 2,
                                 show.labels = F,
                                 annotation_legend = F,
                                 labels.use = c("iPS_cells", "Embryonic_stem_cells", "Neuroepithelial_cell", "Neurons"),
                                 annotation_colors = ann_colors,
                                 color=colorRampPalette(c( "#132E50","#4C89B5", "#FDF8E3", "#F5D411"))(100)
                                 )
```

                                 color=colorRampPalette(c( "#3F7F92","#F9EEEB", "#C76248"))(100)

## Marker Gene Heat Map


```{r Gene Markers}

#subset count matrix for just gene of interests
markers <- c("POU5F1", "NANOG", "KLF4", "NES", "SOX1", "FOXG1")
npc_cnts_subset <- npc_cnts[markers,]
npc_cnts_subset_t <- t(npc_cnts_subset)


#make long table for boxplots
npc_cnts_subset_long <- as.data.frame(npc_cnts_subset_t)
npc_cnts_subset_long$BC <- rownames(npc_cnts_subset_long)
npc_cnts_subset_long <- left_join(npc_cnts_subset_long, inf, by = "BC")
npc_cnts_subset_long$Well <- NULL
npc_cnts_subset_long$Passage <- NULL
npc_cnts_subset_long <- pivot_longer(npc_cnts_subset_long, cols = 1:6, names_to = "Gene", values_to = "Counts")

npc_cnts_subset_long$Gene <- fct_relevel(npc_cnts_subset_long$Gene, "POU5F1", "NANOG", "KLF4", "NES", "SOX1", "FOXG1")


npc_cnts_box <-ggplot(data = npc_cnts_subset_long, aes(x=Celltype, y=Counts))+
  facet_wrap(~ Gene, scales = "free_y")+
  geom_boxplot(aes(fill=Celltype), alpha=0.8, outlier.shape = NA, position=position_dodge(1))+
  geom_point(aes(color=Celltype), position = position_jitterdodge(0.6))+
  ylab("Normalized Expression")+
  scale_fill_manual(values = c("#E8B4B0","#245D82"))+
  scale_color_manual(values = c("#E8B4B0","#245D82"))+
  theme_pub+
  theme(axis.text.x = element_blank(),
        strip.background =element_rect(fill="#c6cad1"),
        axis.title.x = element_blank(),
        legend.position = "none")




```

Figure 
```{r}
heatmapplot <- singleR_heat[[4]]

# Main Figure
legend <- cowplot::get_legend(b6)
void <- ggplot()+ geom_blank() + theme_void()
fig_4 <- cowplot::plot_grid(void, PCAgene12_cell, heatmapplot, npc_cnts_box,
  ncol = 2,
  nrow = 2,
  rel_heights = c(2, 3),
  labels = "auto",
  scale = c(1, .8, .9, .9)
)

```




